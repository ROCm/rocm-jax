#!/usr/bin/env python3

# Copyright 2024 The JAX Authors.
# Copyright 2025 Advanced Micro Devices, Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import argparse
import os
from pathlib import Path
import subprocess
import sys
import tempfile
import glob
import zipfile
import json
import re


MANYLINUX_IMAGE_BASE_NAME = "ghcr.io/rocm/jax-manylinux_2_28"


def _get_labels(image_name):
    """Return image labels via docker inspect; print warning if image is missing."""
    try:
        out = subprocess.check_output(
            ["docker", "inspect", "--format", "{{json .Config.Labels}}", image_name]
        )
        return json.loads(out)
    except subprocess.CalledProcessError:
        print(f"Image '{image_name}' not found locally.")
        return {}


def _check_base_image_exists(base_image_name):
    """Check if a base image exists in GHCR using docker manifest inspect."""
    try:
        subprocess.check_call(
            ["docker", "manifest", "inspect", base_image_name],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        return True
    except subprocess.CalledProcessError:
        return False


def _is_github_actions():
    """Check if the script is running in a GitHub Actions environment."""
    return os.environ.get("GITHUB_ACTIONS") == "true"


def _tag_and_push_latest(local_tag, registry="ghcr.io/rocm"):
    """
    Tag a local Docker image and push it to GHCR with 'latest' tag.

    This function tags a locally built image and pushes it to GitHub Container
    Registry with the 'latest' tag, following the same naming scheme as the
    build-base-docker.yml workflow.

    Note: Pushing to GHCR only occurs when running in a GitHub Actions environment.
    When running locally, the image is tagged but not pushed.

    Args:
        local_tag (str): Local Docker image tag (e.g., "jax-base-ubu24.rocm711")
        registry (str): Container registry prefix (default: "ghcr.io/rocm")

    Raises:
        subprocess.CalledProcessError: If docker tag or push fails
    """
    ghcr_image = "%s/%s:latest" % (registry, local_tag)
    print("Tagging %s as %s" % (local_tag, ghcr_image))
    subprocess.check_call(["docker", "tag", local_tag, ghcr_image])
    
    if _is_github_actions():
        print("Pushing %s" % ghcr_image)
        subprocess.check_call(["docker", "push", ghcr_image])
    else:
        print("Skipping push to GHCR (not running in GitHub Actions)")


def _get_commit_info_from_wheel():
    """Extract commit hashes from commit_info.py inside a jax_rocm*_plugin wheel."""

    wheel_file = glob.glob("wheelhouse/*jax_rocm*_plugin*.whl")[0]

    with zipfile.ZipFile(wheel_file, "r") as whl:
        commit_info_file = next(
            f for f in whl.namelist() if f.endswith("commit_info.py")
        )
        commit_content = whl.read(commit_info_file).decode("utf-8")

    # Parse the commits dictionary from commit_info.py
    # Matches: "repo/name": "abc123def"
    pattern = re.compile(r'[\'"]([^"\']+)[\'"]\s*:\s*[\'"]([0-9a-fA-F]+)[\'"]')
    commits = dict(pattern.findall(commit_content))

    return {
        "xla_commit": commits["ROCm/xla"],
        "jax_commit": commits["jax"],
        "rocm_jax_commit": commits["ROCm/rocm-jax"],
    }


def _docker_image_exists(image):
    """Check if a docker image exists locally or is able to be pulled"""
    # Use docker inspect to see if the image exists
    try:
        subprocess.run(["docker", "inspect", image], check=True)
    except subprocess.CalledProcessError:
        # If we can't find the image with inspect, try pulling it
        print(f"Could not find image '{image}' locally with docker inspect. Attempting to pull it.")
        try:
            subprocess.run(["docker", "pull", image], check=True)
        except subprocess.CalledProcessError:
            print(f"Could not find image '{image}' locally or pull it.")
            return False
    return True


def _construct_manylinux_builder_image_name(rocm_version, rocm_build_job="", rocm_build_num="", therock_path=None):
    """Create an image name that includes the ROCm ersion, build job, build number, etc"""
    return "{base_name}-{rocm_type}-{rocm_version}{rocm_build_job}{rocm_build_num}".format(
        base_name=MANYLINUX_IMAGE_BASE_NAME,
        rocm_type="therock" if therock_path else "rocm",
        rocm_version=rocm_version,
        rocm_build_job="-%s" % rocm_build_job if rocm_build_job else "",
        rocm_build_num="-%s" % rocm_build_num if rocm_build_num else "",
    )


def build_manylinux_dockers(
    rocm_version, rocm_build_job="", rocm_build_num="", therock_path=None, tag=None
):
    """Build a manylinux image that can be used for building release-ready JAX wheels"""
    if tag:
        constructed_tag = tag
    else:
        constructed_tag = _construct_manylinux_builder_image_name(rocm_version, rocm_build_job, rocm_build_num, therock_path)

    if therock_path:
        cmd = [
            "docker",
            "build",
            "-t=%s" % constructed_tag,
            "--file=docker/manylinux/Dockerfile.jax-manylinux_2_28-therock",
            "--build-arg=ROCM_VERSION=%s" % rocm_version,
            "--build-arg=THEROCK_PATH=%s" % therock_path,
            #"--build-context=%s" % therock_path,
            ".",
        ]
    else:
        cmd = [
            "docker",
            "build",
            "-t=%s" % constructed_tag,
            "--file=docker/manylinux/Dockerfile.jax-manylinux_2_28-rocm",
            "--build-arg=ROCM_VERSION=%s" % rocm_version,
            "--build-arg=ROCM_BUILD_JOB=%s" % rocm_build_job,
            "--build-arg=ROCM_BUILD_NUM=%s" % rocm_build_num,
            ".",
        ]
    subprocess.run(cmd, check=True)
    return constructed_tag


def dist_wheels(
    rocm_version,
    python_versions,
    xla_source_dir,
    jax_source_dir,
    rocm_build_job="",
    rocm_build_num="",
    therock_path=None,
    rbe=False,
    compiler="gcc",
    builder_image=None,
):
    jax_plugin_dir = "jax_rocm_plugin"

    # If we weren't passed a builder image in the args, create an image
    local_builder_image = builder_image
    if not local_builder_image:
        print("No manylinux builder image passed. Building a new builder image...")
        local_builder_image = build_manylinux_dockers(
            rocm_version=rocm_version,
            rocm_build_job=rocm_build_job,
            rocm_build_num=rocm_build_num,
            therock_path=therock_path,
        )
    # If builder-image is set to 'search', try and find one based off of the passed ROCm info
    elif local_builder_image == "search":
        print("Searching for manylinux builder image...")
        local_builder_image = _construct_manylinux_builder_image_name(rocm_version, rocm_build_job, rocm_build_num, therock_path)
        if not _docker_image_exists(local_builder_image):
            print(f"ERROR: Builder image '{local_builder_image}' does not exist")
            exit(1)

    # Build the wheels
    cmd = [
        "python3",
        "build/rocm/ci_build",
        "--rocm-version=%s" % rocm_version,
        "--python-versions=%s" % ",".join(python_versions),
        "--compiler=%s" % compiler,
        "--builder-image=%s" % local_builder_image,
    ]

    if xla_source_dir:
        xla_path = os.path.realpath(os.path.expanduser(xla_source_dir))
        cmd.append("--xla-source-dir=%s" % xla_path)

    if jax_source_dir:
        jax_path = os.path.realpath(os.path.expanduser(jax_source_dir))
        cmd.append("--jax-source-dir=%s" % jax_path)

    if rbe:
        cmd.append("--rbe")

    cmd.append("dist_wheels")
    subprocess.check_call(cmd, cwd=jax_plugin_dir)


def _apply_filters(docker_filters, dockerfile_basename, docker_dir="docker"):
    """
    Collect Dockerfile paths matching a basename prefix and optional substring filters.

    This helper scans `docker_dir` for files whose names start with `dockerfile_basename`.
    If `docker_filters` is provided (non-empty), only files that contain at least one of
    the specified substrings in their filename are included. If `docker_filters` is None
    or empty, all prefix-matching files are included.

    Note:
        - Matching is case-sensitive for both the prefix and substrings.
        - If a filename contains multiple substrings from `docker_filters`, its path
          may be appended multiple times (one per match).
        - The order of results follows the order returned by `os.listdir`.

    Args:
        docker_filters (Iterable[str] | None):
            Substrings to filter filenames by. When provided, a file is selected if
            any substring is present in its name. If None or empty, no substring
            filtering is applied.
        dockerfile_basename (str):
            Filename prefix to match (e.g., "Dockerfile" will match "Dockerfile",
            "Dockerfile.rocm", etc.).
        docker_dir (str, optional):
            Directory to search for Dockerfiles. Defaults to "docker".

    Returns:
        list[str]:
            A list of filesystem paths to matching Dockerfiles.

    Raises:
        FileNotFoundError:
            If `docker_dir` does not exist.
        PermissionError:
            If the process lacks permission to list or access `docker_dir`.
    """
    dockerfiles = []
    for f in os.listdir(docker_dir):
        if f.startswith(dockerfile_basename):
            path = os.path.join(docker_dir, f)

            if docker_filters:
                for substr in docker_filters:
                    if substr in f:
                        dockerfiles.append(path)
            else:
                dockerfiles.append(path)

    return dockerfiles


def _run_docker(
    dockerfile,
    rocm_version,
    rocm_build_job,
    rocm_build_num,
    therock_path,
    tag,
    custom_flags=[],
):
    """
    Build a Docker image with ROCm-related build arguments and an optional “therock”
    build context.

    This helper assembles and executes a `docker build` command using the provided
    Dockerfile and ROCm parameters. It also manages the “therock” build context in
    one of two ways:
      - If `therock_path` is provided and exists on the filesystem, it is mounted
        as a named build context (`--build-context=therock=<path>`) and the build
        arg `THEROCK_PATH` is set to `/tmp/therock/`.
      - Otherwise, a temporary directory is created with a `therock/` subfolder
        and used as the build context. In this case, if `therock_path` was provided
        but does not exist, `THEROCK_PATH` is set to that (nonexistent) path.

    The build context root is the current directory (“.”). Any additional Docker
    build flags can be injected via `custom_flags`.

    Args:
        dockerfile (str or pathlib.Path):
            Path to the Dockerfile to use (passed to `docker build -f`).
        rocm_version (str):
            ROCm version string (e.g., "6.2"), passed as `--build-arg=ROCM_VERSION`.
        rocm_build_job (str):
            ROCm build job identifier, passed as `--build-arg=ROCM_BUILD_JOB`.
        rocm_build_num (str or int):
            ROCm build number, passed as `--build-arg=ROCM_BUILD_NUM`.
        therock_path (str or pathlib.Path or None):
            Path to the local “therock” directory to supply as a named build context.
            If provided and exists, used directly; otherwise a temporary directory
            is created and used. Also influences the `THEROCK_PATH` build arg as
            described above.
        tag (str):
            Docker image tag to assign (passed as `--tag=<tag>`).
        custom_flags (list[str], optional):
            Additional `docker build` flags to append (e.g., ["--no-cache", "--pull"]).
            Defaults to an empty list.

    Raises:
        subprocess.CalledProcessError:
            If `docker build` exits with a non-zero status.
        FileNotFoundError:
            If the `docker` CLI is not available in PATH.
        Exception:
            Any other error raised while constructing temporary paths or invoking
            the subprocess.
    """
    cmd = [
        "docker",
        "build",
        "-f",
        dockerfile,
        "--build-arg=ROCM_VERSION=%s" % rocm_version,
        "--build-arg=ROCM_BUILD_JOB=%s" % rocm_build_job,
        "--build-arg=ROCM_BUILD_NUM=%s" % rocm_build_num,
        "--tag=%s" % tag,
    ]
    cmd.extend(custom_flags)

    if therock_path and Path(therock_path).exists():
        cmd.append("--build-arg=THEROCK_PATH=/tmp/therock/")
        cmd.append("--build-context=therock=%s" % therock_path)
    else:
        if therock_path:
            cmd.append("--build-arg=THEROCK_PATH=%s" % therock_path)
        temp_path = Path(tempfile.mkdtemp()) / "therock"
        temp_path.mkdir(exist_ok=True)
        cmd.append("--build-context=therock=%s" % temp_path)

    # context dir
    cmd.append(".")

    subprocess.check_call(cmd)


def build_dockers(
    rocm_version: str,
    python_versions: str,
    rocm_build_job="",
    rocm_build_num="",
    therock_path=None,
    tag_base=None,
    docker_filters=None,
):
    commit_info = _get_commit_info_from_wheel()
    dockerfiles = _apply_filters(docker_filters, "Dockerfile.jax")

    rocm_ver_tag = "rocm%s" % "".join(rocm_version.split("."))
    rocm_version_tag = "".join(rocm_version.split("."))
    plugin_namespace = rocm_version[0]
    if plugin_namespace == "6":
        plugin_namespace = "60"
    print(f"Setting Plugin Namespace to {plugin_namespace}")

    extra_args = [
        "--build-arg=XLA_COMMIT=%s" % commit_info["xla_commit"],
        "--build-arg=JAX_COMMIT=%s" % commit_info["jax_commit"],
        "--build-arg=ROCM_JAX_COMMIT=%s" % commit_info["rocm_jax_commit"],
        "--build-arg=PLUGIN_NAMESPACE=%s" % plugin_namespace,
        "--build-arg=ROCM_VERSION_TAG=%s" % rocm_version_tag,
        "--build-context=wheels=./wheelhouse",
    ]
    print(f"Extra args sent to docker: {extra_args}")
    for dockerfile in dockerfiles:
        _, tag_suffix = dockerfile.split(".", 1)

        # Extract ubuntu version from tag_suffix (e.g., "jax-ubu24" -> "ubu24")
        # tag_suffix format is "jax-ubu<version>"
        ubuntu_version = tag_suffix.split("-")[-1]  # "jax-ubu24" -> "ubu24"

        # Construct base image name
        base_image_name = "ghcr.io/rocm/jax-base-%s.rocm%s" % (
            ubuntu_version,
            rocm_version_tag,
        )

        # Check if base image exists
        if not _check_base_image_exists(base_image_name):
            print(
                "Base image %s not found in registry. Building it..." % base_image_name
            )
            # Build the base image
            build_base_dockers(
                rocm_version=rocm_version,
                python_versions=python_versions,
                rocm_build_job=rocm_build_job,
                rocm_build_num=rocm_build_num,
                therock_path=therock_path,
                add_llvm=False,  # Base images, not dev images
                docker_filters=[ubuntu_version],  # Filter for specific ubuntu version
                push_latest=True,  # Tag and push as latest to preserve Dockerfile invariant
            )
        else:
            print("Base image %s found in registry." % base_image_name)

        if tag_base:
            tag = "%s.%s.%s" % (tag_base, tag_suffix, rocm_ver_tag)
        else:
            tag = "%s.%s" % (tag_suffix, rocm_ver_tag)

        print("Building dockerfile=%r to tag=%r" % (dockerfile, tag))

        _run_docker(
            dockerfile,
            rocm_version,
            rocm_build_job,
            rocm_build_num,
            therock_path,
            tag,
            extra_args,
        )


def build_base_dockers(
    rocm_version: str,
    python_versions: str,
    rocm_build_job="",
    rocm_build_num="",
    add_llvm=False,
    llvm_version=18,
    therock_path=None,
    tag_base=None,
    docker_filters=None,
    push_latest=False,
):
    dockerfiles = _apply_filters(docker_filters, "Dockerfile.base")
    rocm_ver_tag = "rocm%s" % "".join(rocm_version.split("."))

    extra_args = []
    if add_llvm:
        extra_args = [
            f"--build-arg=INSTALL_LLVM={int(add_llvm)}",
            f"--build-arg=LLVM_VERSION={llvm_version}",
        ]

    for dockerfile in dockerfiles:
        _, tag_suffix = dockerfile.split(".", 1)
        if add_llvm:
            # Change prefix from "base" to "dev" for LLVM images
            tag_suffix = tag_suffix.replace("base-", "dev-", 1)

        # Add "jax-" prefix to all tags
        tag_suffix = "jax-" + tag_suffix

        if tag_base:
            tag = "%s.%s.%s" % (tag_base, tag_suffix, rocm_ver_tag)
        else:
            tag = "%s.%s" % (tag_suffix, rocm_ver_tag)

        print("Building dockerfile=%r to tag=%r" % (dockerfile, tag))

        _run_docker(
            dockerfile,
            rocm_version,
            rocm_build_job,
            rocm_build_num,
            therock_path,
            tag,
            extra_args,
        )

        # Tag and push as latest if requested
        if push_latest:
            _tag_and_push_latest(tag)


def test(image_name, test_cmd=None):
    """Run unit tests like CI would inside a JAX image."""

    labels = _get_labels(image_name)

    print("ROCm JAX Build Information")
    if "com.amdgpu.rocm_jax_commit" in labels:
        print(
            f"rocm/rocm-jax commit hash: {labels['com.amdgpu.rocm_jax_commit']}",
            flush=True,
        )
    if "com.amdgpu.jax_commit" in labels:
        print(f"rocm/jax commit hash: {labels['com.amdgpu.jax_commit']}", flush=True)
    if "com.amdgpu.xla_commit" in labels:
        print(f"rocm/xla commit hash: {labels['com.amdgpu.xla_commit']}", flush=True)

    if not test_cmd:
        test_cmd = (
            "python jax_rocm_plugin/build/rocm/run_single_gpu.py -c && "
            "python jax_rocm_plugin/build/rocm/run_multi_gpu.py"
        )

    gpu_args = [
        "--device=/dev/kfd",
        "--device=/dev/dri",
        "--group-add",
        "video",
        "--cap-add=SYS_PTRACE",
        "--security-opt",
        "seccomp=unconfined",
        "--shm-size",
        "16G",
        "--env-file",
        "/etc/podinfo/gha-gpu-isolation-settings"
    ]

    cmd = [
        "docker",
        "run",
        "--rm",
    ]

    if os.isatty(sys.stdout.fileno()):
        cmd.append("-it")

    # NOTE(mrodden): we need jax source dir for the unit test code only,
    # JAX and jaxlib are already installed from wheels
    mounts = [
        "-v",
        os.path.abspath(".") + ":/rocm-jax",
    ]

    cmd.extend(mounts)
    cmd.extend(gpu_args)

    container_cmd = "cd /rocm-jax && %s" % test_cmd

    cmd.append(image_name)
    cmd.extend(
        [
            "bash",
            "-c",
            container_cmd,
        ]
    )

    subprocess.check_call(cmd)


def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument(
        "--base-docker",
        default="",
        help="Argument to override base docker in dockerfile",
    )

    p.add_argument(
        "--python-versions",
        type=lambda x: x.split(","),
        default="3.11,3.12,3.13,3.14",
        help="Comma separated list of CPython versions to build wheels for",
    )

    p.add_argument(
        "--rocm-version",
        help="ROCm version used for building wheels, testing, and installing into Docker image",
    )

    p.add_argument(
        "--rocm-build-job",
        default="",
        help="ROCm build job for development ROCm builds. Requires --rocm-build-num to also be set. Is mutually exclusive with --therock-path.",
    )

    p.add_argument(
        "--rocm-build-num",
        default="",
        help="ROCm build number for development ROCm builds. Requires --rocm-build-job to also be set. Is mutually exclusive with --therock-path.",
    )

    p.add_argument(
        "--therock-path",
        default="",
        help="URL to download a tarball of TheRock, or a local directory name pointing to a tarball or directory containing TheRock. This argument is mutually exclusive with --rocm-build-job and --rocm-build-num.",
    )

    p.add_argument(
        "--xla-source-dir",
        help="Path to XLA source to use during plugin and jaxlib build, instead of builtin XLA",
    )

    p.add_argument(
        "--jax-source-dir",
        help="Optional JAX source directory. When provided, builds jaxlib wheel and copies to wheelhouse.",
    )

    p.add_argument(
        "--compiler",
        choices=["gcc", "clang"],
        default="clang",
        help="Compiler backend to use when compiling jax/jaxlib",
    )

    subp = p.add_subparsers(dest="action", required=True)

    ml_parser = subp.add_parser("build_manylinux_dockers")
    ml_parser.add_argument(
        "--tag", "-t", type=str, help="Override the default image name and tag"
    )

    dwp = subp.add_parser("dist_wheels")
    dwp.add_argument("--rbe", action="store_true", help="Use Bazel RBE for building")
    dwp.add_argument(
        "--builder-image",
        "-b",
        type=str,
        help="Name of the docker image to build with",
    )

    dtestp = subp.add_parser("test_docker")
    dtestp.add_argument("--docker-build-only", action="store_true")
    dtestp.add_argument(
        "--jax-version",
        default="latest",
        help="JAX version that will be install via pip in test image.",
    )

    bdp = subp.add_parser("build_dockers")
    bdp.add_argument(
        "--filter",
        "-f",
        type=str,
        help="Comma separated strings to filter Dockerfiles to build. Substring match",
        default="",
    )

    bbasedp = subp.add_parser("build_base_dockers")
    bbasedp.add_argument(
        "--filter",
        "-f",
        type=str,
        help="Comma separated strings to filter Dockerfiles to build. Substring match",
        default="",
    )
    bbasedp.add_argument(
        "--install-llvm",
        help="Enable the installation of LLVM in the containers.",
        action="store_true",
    )
    bbasedp.add_argument(
        "--llvm-version",
        help="Set the version number of LLVM to be installed.",
        type=int,
    )

    testp = subp.add_parser("test")
    testp.add_argument(
        "--test-cmd", help="Command which will be run inside the test container"
    )
    testp.add_argument("image_name")

    args = p.parse_args()

    # Make sure that the user hasn't tried to set both --therock-path and either --rocm-build-job or --rocm-build-num
    if args.therock_path and (args.rocm_build_job or args.rocm_build_num):
        p.error(
            "You cannot set both --therock-path and --rocm-build-job/--rocm-build-num."
        )

    # Note: --rocm-build-job can be used alone - build_num will be auto-fetched
    # from Jenkins. But --rocm-build-num requires --rocm-build-job.
    if args.rocm_build_num and not args.rocm_build_job:
        p.error("--rocm-build-num requires --rocm-build-job to also be set")

    return args


def main():
    args = parse_args()

    if args.action == "build_manylinux_dockers":
        build_manylinux_dockers(
            rocm_version=args.rocm_version,
            rocm_build_job=args.rocm_build_job,
            rocm_build_num=args.rocm_build_num,
            therock_path=args.therock_path,
            tag=args.tag,
        )

    if args.action == "dist_wheels":
        dist_wheels(
            rocm_version=args.rocm_version,
            python_versions=args.python_versions,
            xla_source_dir=args.xla_source_dir,
            jax_source_dir=args.jax_source_dir,
            rocm_build_job=args.rocm_build_job,
            rocm_build_num=args.rocm_build_num,
            therock_path=args.therock_path,
            rbe=args.rbe,
            compiler=args.compiler,
            builder_image=args.builder_image,
        )

    if args.action == "build_dockers":
        filters = args.filter.split(",")

        build_dockers(
            rocm_version=args.rocm_version,
            python_versions=args.python_versions,
            rocm_build_job=args.rocm_build_job,
            rocm_build_num=args.rocm_build_num,
            therock_path=args.therock_path,
            docker_filters=filters,
        )
    elif args.action == "build_base_dockers":
        filters = args.filter.split(",")

        build_base_dockers(
            rocm_version=args.rocm_version,
            python_versions=args.python_versions,
            rocm_build_job=args.rocm_build_job,
            rocm_build_num=args.rocm_build_num,
            therock_path=args.therock_path,
            docker_filters=filters,
            add_llvm=args.install_llvm,
            llvm_version=args.llvm_version,
        )

    elif args.action == "test_docker":
        image_name = "rocm/jax-test"

        if not os.path.exists("./jax"):
            print(
                "Integration tests require a local 'jax' repo for jax test code.",
                file=sys.stderr,
            )
            sys.exit(-1)

        build_test_docker(
            args.rocm_version,
            args.python_versions[0],
            rocm_build_job=args.rocm_build_job,
            rocm_build_num=args.rocm_build_num,
            tag=image_name,
            jax_version=args.jax_version,
        )

        if args.docker_build_only:
            return

    elif args.action == "test":
        test(args.image_name, args.test_cmd)


if __name__ == "__main__":
    main()
