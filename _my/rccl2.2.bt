config = {
    max_map_keys = 8;            // default max number of keys in a map
    unstable_map_decl=enable;    // for toplevel let @probes
    print_maps_on_exit = false;  // no useful info there
    perf_rb_pages = 4096      // size of output buffer in pages
    // perf_rb_pages = 1       // playing with this helps to cause or avoid the hang
}

// probes that don't have a dedicated body will use this map to translate a probe name to id.
// Not sure it's very efficient, but the alternative is to make a separate body per probe, which is
// to cumbersome. The map, though, mostly works.
let @probes = hash(9);  // number must correspond to the number of mappings in the begin{} block
begin{
    // uprobe, capital letters
    @probes["uprobe:/opt/rocm/lib/librccl.so.1:ncclGroupStart"] = "GS";
    @probes["uprobe:/opt/rocm/lib/librccl.so.1:ncclGroupEnd"] = "GE";

    // uretprobe, lowercase letters. Otherwise must correspond to uprobe
    @probes["uretprobe:/opt/rocm/lib/librccl.so.1:ncclGroupStart"] = "gs";
    @probes["uretprobe:/opt/rocm/lib/librccl.so.1:ncclGroupEnd"] = "ge";
    @probes["uretprobe:/opt/rocm/lib/librccl.so.1:ncclAllReduce"] = "ar";
    @probes["uretprobe:/opt/rocm/lib/librccl.so.1:ncclReduceScatter"] = "rs";
    @probes["uretprobe:/opt/rocm/lib/librccl.so.1:ncclAllGather"] = "ag";

    @probes["uretprobe:/opt/rocm/lib/librccl.so.1:ncclCommInitRankConfig"] = "ic";
    @probes["uretprobe:/opt/rocm/lib/librccl.so.1:ncclCommSplit"] = "cs";
}


////////////// SIMPLE FUNCTIONS /////////

uprobe:/opt/rocm/lib/librccl.so.1:ncclGroupStart,
uprobe:/opt/rocm/lib/librccl.so.1:ncclGroupEnd
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    // $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        // @funcs[$thrd] = $ip;

        printf("%s %llx,%llx\n", @probes[probe],$thrd,$ts_start);
    }
}

uretprobe:/opt/rocm/lib/librccl.so.1:ncclGroupStart,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclGroupEnd,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclAllReduce,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclReduceScatter,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclAllGather
{
    $ts_end = nsecs;
    $thrd = tid(init); // tid(init) is important for v0.23+

    @depth[$thrd]--;
    $dpt = @depth[$thrd];
    // $ts_start = @start[$thrd];
    // $callee_addr = @funcs[$thrd];

    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // delete(@start, $thrd);
        // delete(@start[$thrd]);

        // delete(@funcs, $thrd);
        // delete(@funcs[$thrd]);

        printf("%s %llx,%llx\n", @probes[probe],$thrd, $ts_end);
    }
}

////////////// SPECIAL FUNCTIONS /////////

uprobe:/opt/rocm/lib/librccl.so.1:ncclAllReduce
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    // $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        // @funcs[$thrd] = $ip;

        printf("AR %llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", $thrd,$ts_start,arg0,arg1,arg2,arg3,arg4,arg5);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclReduceScatter
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    // $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        // @funcs[$thrd] = $ip;

        printf("RS %llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", $thrd,$ts_start,arg0,arg1,arg2,arg3,arg4,arg5);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclAllGather
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    // $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        // @funcs[$thrd] = $ip;

        printf("AG %llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", $thrd,$ts_start,arg0,arg1,arg2,arg3,arg4,arg5);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclCommInitRankConfig
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    // $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        // @funcs[$thrd] = $ip;

        @comm[$thrd] = arg0;
        printf("IC %llx,%llx,%llx,%llx\n", $thrd,$ts_start,arg1,arg2);
    }
}

uretprobe:/opt/rocm/lib/librccl.so.1:ncclCommInitRankConfig
,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclCommSplit
{
    $ts_end = nsecs;
    $thrd = tid(init); // tid(init) is important for v0.23+

    @depth[$thrd]--;
    $dpt = @depth[$thrd];
    // $ts_start = @start[$thrd];
    // $callee_addr = @funcs[$thrd];

    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // delete(@start, $thrd);
        // delete(@start[$thrd]);

        // delete(@funcs, $thrd);
        // delete(@funcs[$thrd]);

        printf("%s %llx,%llx,%llx\n", @probes[probe],$thrd, $ts_end, *(uint64*)@comm[$thrd]);
        delete(@comm[$thrd]);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclCommSplit
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    // $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        // @funcs[$thrd] = $ip;

        @comm[$thrd] = arg3;
        printf("CS %llx,%llx,%llx,%llx,%llx\n", $thrd,$ts_start,arg0,arg1,arg2);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:arechLaunchKernel
{
    // arg0 is void* kernelFn and is the same for all invocations
    // arg1 is bool is_ext and  is the same for all invocations
    $ts_start = nsecs;

    $n_tasks_m_1 = (arg0 & 3);
    $ptr = (uint64*) (arg0 & 0xFFFFFFFFFFFFFFFC);
    // also saving func_tag (0), comm (1), and stream (2)
    if (0==$n_tasks_m_1){
        printf("L %llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg0,arg1,arg2,*$ptr,
            *($ptr+1),*($ptr+2) );
    }else if (1==$n_tasks_m_1){
        printf("L %llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg0,arg1,arg2,*$ptr,
            *($ptr+1),*($ptr+2),
            *($ptr+3),*($ptr+4)
        );
    }else if (2==$n_tasks_m_1){
        printf("L %llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg0,arg1,arg2,*$ptr,
            *($ptr+1),*($ptr+2),
            *($ptr+3),*($ptr+4),
            *($ptr+5),*($ptr+6)
        );
    }else if (3==$n_tasks_m_1){
        printf("L %llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg0,arg1,arg2,*$ptr,
            *($ptr+1),*($ptr+2),
            *($ptr+3),*($ptr+4),
            *($ptr+5),*($ptr+6),
            *($ptr+7),*($ptr+8)
        );
    }else{
        printf("UNSUPPORTED TASK COUNT = %u!\n", $n_tasks_m_1);
        exit();
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:arechCallback
{
    printf("l %llx,%llx\n", nsecs, arg0); // tid makes no sense here, it's HIP internal thread
}
