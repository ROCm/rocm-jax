config = {
    max_map_keys = 8;
    perf_rb_pages = 4096
}


////////////// SIMPLE FUNCTIONS /////////

uprobe:/opt/rocm/lib/librccl.so.1:ncclGroupStart,
uprobe:/opt/rocm/lib/librccl.so.1:ncclGroupEnd
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        @funcs[$thrd] = $ip;

        printf("%s,%llx,%u,%llx\n", probe, $ip, $thrd, $ts_start);
    }
}

uretprobe:/opt/rocm/lib/librccl.so.1:ncclGroupStart,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclGroupEnd,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclAllReduce,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclReduceScatter,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclAllGather
{
    $ts_end = nsecs;
    $thrd = tid(init); // tid(init) is important for v0.23+

    @depth[$thrd]--;
    $dpt = @depth[$thrd];
    // $ts_start = @start[$thrd];
    $callee_addr = @funcs[$thrd];

    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // delete(@start, $thrd);
        // delete(@start[$thrd]);

        // delete(@funcs, $thrd);
        delete(@funcs[$thrd]);

        printf("%s,%llx,%llx,%u,%llx\n", probe, reg("ip"), $callee_addr, $thrd, $ts_end);
    }
}

////////////// SPECIAL FUNCTIONS /////////

uprobe:/opt/rocm/lib/librccl.so.1:ncclAllReduce
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        @funcs[$thrd] = $ip;

        printf("AR %u,%llx,%llx,%llx,%llx,%x,%x,%llx\n", $thrd,$ts_start, arg0,arg1,arg2,arg3,arg4,arg5);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclReduceScatter
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        @funcs[$thrd] = $ip;

        printf("RS %u,%llx,%llx,%llx,%llx,%x,%x,%llx\n", $thrd,$ts_start, arg0,arg1,arg2,arg3,arg4,arg5);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclAllGather
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        @funcs[$thrd] = $ip;

        printf("AG %u,%llx,%llx,%llx,%llx,%x,%llx\n", $thrd, $ts_start, arg0,arg1,arg2,arg3,arg4);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclCommInitRankConfig
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        @funcs[$thrd] = $ip;

        @comm[$thrd] = arg0;
        printf("%s,%llx,%u,%llx,%x,%x\n", probe, $ip, $thrd, $ts_start, arg1,arg2);
    }
}

uretprobe:/opt/rocm/lib/librccl.so.1:ncclCommInitRankConfig
,
uretprobe:/opt/rocm/lib/librccl.so.1:ncclCommSplit
{
    $ts_end = nsecs;
    $thrd = tid(init); // tid(init) is important for v0.23+

    @depth[$thrd]--;
    $dpt = @depth[$thrd];
    // $ts_start = @start[$thrd];
    $callee_addr = @funcs[$thrd];

    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // delete(@start, $thrd);
        // delete(@start[$thrd]);

        // delete(@funcs, $thrd);
        delete(@funcs[$thrd]);

        printf("%s,%llx,%llx,%u,%llx,%llx\n", probe, reg("ip"), $callee_addr, $thrd, $ts_end, *(uint64*)@comm[$thrd]);
        delete(@comm[$thrd]);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:ncclCommSplit
{
    $thrd = tid(init);  // tid(init) is important for v0.23+
    $ip = reg("ip");

    $dpt = @depth[$thrd];
    @depth[$thrd]++;

    $ts_start = nsecs;
    if ($dpt <= 0){
        if ($dpt < 0){
            printf("NEGATIVE DEPTH");
            // signal("KILL");
            exit();
        }

        // @start[$thrd] = $ts_start;
        @funcs[$thrd] = $ip;

        @comm[$thrd] = arg3;
        printf("%s,%llx,%u,%llx,%llx,%x,%x\n", probe, $ip, $thrd, $ts_start, arg0,arg1,arg2);
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:arechLaunchKernel
{
    // arg0 is void* kernelFn and is the same for all invocations
    // arg1 is bool is_ext and  is the same for all invocations
    $ts_start = nsecs;

    $n_tasks_m_1 = (arg2 & 3);
    $ptr = (uint64*) (arg2 & 0xFFFFFFFFFFFFFFFC);

    if (0==$n_tasks_m_1){
        printf("L %u,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg2,*$ptr,
            *($ptr+1),*($ptr+2) );
    }else if (1==$n_tasks_m_1){
        printf("L %u,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg2,*$ptr,
            *($ptr+1),*($ptr+2),
            *($ptr+3),*($ptr+4)
        );
    }else if (2==$n_tasks_m_1){
        printf("L %u,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg2,*$ptr,
            *($ptr+1),*($ptr+2),
            *($ptr+3),*($ptr+4),
            *($ptr+5),*($ptr+6)
        );
    }else if (3==$n_tasks_m_1){
        printf("L %u,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n", tid(init),$ts_start,arg2,*$ptr,
            *($ptr+1),*($ptr+2),
            *($ptr+3),*($ptr+4),
            *($ptr+5),*($ptr+6),
            *($ptr+7),*($ptr+8)
        );
    }else{
        printf("UNSUPPORTED TASK COUNT = %u!\n", $n_tasks_m_1);
        exit();
    }
}

uprobe:/opt/rocm/lib/librccl.so.1:arechCallback
{
    printf("E %llx,%llx\n", nsecs, arg0); // tid makes no sense here, it's HIP internal thread
}
