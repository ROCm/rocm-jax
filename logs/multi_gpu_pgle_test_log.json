{"created": 1763600215.678456, "duration": 67.57202744483948, "exitcode": 1, "root": "/dockerx/rocm/rocm-jax/jax", "environment": {}, "summary": {"failed": 6, "passed": 2, "skipped": 1, "total": 9, "collected": 9}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests/pgle_test.py", "type": "Module"}]}, {"nodeid": "tests/pgle_test.py::PgleTest", "outcome": "passed", "result": [{"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgle", "type": "TestCaseFunction", "lineno": 134}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithAot", "type": "TestCaseFunction", "lineno": 196}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithCommandBuffers0", "type": "TestCaseFunction", "lineno": 483}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithCommandBuffers1", "type": "TestCaseFunction", "lineno": 483}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithPersistentCache", "type": "TestCaseFunction", "lineno": 220}, {"nodeid": "tests/pgle_test.py::PgleTest::testPGLEProfilerGetFDOProfile", "type": "TestCaseFunction", "lineno": 60}, {"nodeid": "tests/pgle_test.py::PgleTest::testPGLEProfilerGetFDOProfileLarge", "type": "TestCaseFunction", "lineno": 93}, {"nodeid": "tests/pgle_test.py::PgleTest::testPassingFDOProfile", "type": "TestCaseFunction", "lineno": 325}, {"nodeid": "tests/pgle_test.py::PgleTest::testPersistentCachePopulatedWithAutoPgle", "type": "TestCaseFunction", "lineno": 366}]}, {"nodeid": "tests/pgle_test.py", "outcome": "passed", "result": [{"nodeid": "tests/pgle_test.py::PgleTest", "type": "UnitTestCase"}]}], "tests": [{"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgle", "lineno": 134, "outcome": "failed", "keywords": ["testAutoPgle", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.00021314527839422226, "outcome": "passed"}, "call": {"duration": 0.44160829298198223, "outcome": "failed", "crash": {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled."}, "traceback": [{"path": "jax/tests/pgle_test.py", "lineno": 162, "message": ""}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 263, "message": "in cache_miss"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 146, "message": "in _python_pjit_helper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 1622, "message": "in _pjit_call_impl_python"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 359, "message": "in wrapper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py", "lineno": 1367, "message": "in __call__"}, {"path": "/usr/lib/python3.12/contextlib.py", "lineno": 144, "message": "in __exit__"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning"}], "longrepr": "self = <tests.pgle_test.PgleTest testMethod=testAutoPgle>\n\n    def testAutoPgle(self):\n      mesh = jtu.create_mesh((2,), ('x',))\n    \n      with tempfile.TemporaryDirectory() as dump_dir:\n        compile_options = {\n            'xla_gpu_enable_latency_hiding_scheduler': 'True',\n            'xla_dump_to': dump_dir,\n            'xla_gpu_experimental_dump_fdo_profiles': 'True',\n        }\n        # TODO(b/376647494): Remove this flag once the bug is fixed.\n        @partial(\n            jax.jit,\n            in_shardings=NamedSharding(mesh, PartitionSpec('x')),\n            out_shardings=NamedSharding(mesh, PartitionSpec('x')),\n            compiler_options=compile_options,\n        )\n        def f(x):\n          return x * 2\n    \n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n        expected = x * 2\n    \n        with config.pgle_profiling_runs(2), config.enable_pgle(True):\n          # Run 1: Module should be compiled without FDO. Two modules are expected\n          # One is the function f, the other one is multi slice module\n          with jtu.count_pjit_cpp_cache_miss() as cache_miss_count:\n>           self.assertArraysEqual(f(x), expected)\n                                   ^^^^\n\njax/tests/pgle_test.py:162: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:263: in cache_miss\n    executable, pgle_profiler, const_args) = _python_pjit_helper(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:146: in _python_pjit_helper\n    out_flat, compiled, profiler, const_args = _pjit_call_impl_python(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:1622: in _pjit_call_impl_python\n    return (compiled.unsafe_call(*computation.const_args, *args),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:359: in wrapper\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py:1367: in __call__\n    with profiler.PGLEProfiler.trace(self.pgle_profiler):\n/usr/lib/python3.12/contextlib.py:144: in __exit__\n    next(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'jax._src.profiler.PGLEProfiler'>\nrunner = <jax._src.profiler.PGLEProfiler object at 0x7f1ddc0d3a70>\n\n    @classmethod\n    @contextmanager\n    def trace(cls, runner: PGLEProfiler | None):\n      if (runner is None or runner.is_running()\n          or not runner.is_enabled() or runner.is_fdo_consumed()):\n        yield\n      else:\n        options = _profiler.ProfileOptions()\n        options.enable_hlo_proto = True\n        options.raise_error_on_start_failure = True\n        runner.current_session = _profiler.ProfilerSession(options)\n    \n        try:\n          yield\n        finally:\n          xspace = runner.current_session.stop()\n          runner.fdo_profiles.append(\n              _profiler.get_fdo_profile(xspace)\n          )\n          runner.current_session = None\n    \n          runner.called_times += 1\n          if runner.fdo_profiles[-1] == b'':\n>           warnings.warn(\n                \"PGLE collected an empty trace, may be due to contention with \"\n                \"another tool that subscribes to CUPTI, such as Nsight Systems - check \"\n                \"for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. \"\n                \"Consider populating a persistent compilation cache with PGLE enabled, \"\n                \"and then profiling a second run that has the \"\n                \"JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\",\n                RuntimeWarning)\nE           RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\n\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:468: RuntimeWarning"}, "teardown": {"duration": 0.00021543912589550018, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithAot", "lineno": 196, "outcome": "passed", "keywords": ["testAutoPgleWithAot", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.00021904334425926208, "outcome": "passed"}, "call": {"duration": 0.48151443153619766, "outcome": "passed"}, "teardown": {"duration": 0.0002395128831267357, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithCommandBuffers0", "lineno": 483, "outcome": "failed", "keywords": ["testAutoPgleWithCommandBuffers0", "__wrapped__", "__x_params_repr__", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.0002138158306479454, "outcome": "passed"}, "call": {"duration": 0.23342145048081875, "outcome": "failed", "crash": {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled."}, "traceback": [{"path": "jax/tests/pgle_test.py", "lineno": 524, "message": ""}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 263, "message": "in cache_miss"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 146, "message": "in _python_pjit_helper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 1622, "message": "in _pjit_call_impl_python"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 359, "message": "in wrapper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py", "lineno": 1367, "message": "in __call__"}, {"path": "/usr/lib/python3.12/contextlib.py", "lineno": 144, "message": "in __exit__"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning"}], "longrepr": "self = <tests.pgle_test.PgleTest testMethod=testAutoPgleWithCommandBuffers0>\nenable_compilation_cache = True\n\n    @parameterized.parameters([True, False])\n    @jtu.thread_unsafe_test()\n    def testAutoPgleWithCommandBuffers(self, enable_compilation_cache):\n      with (config.pgle_profiling_runs(1),\n            config.enable_compilation_cache(enable_compilation_cache),\n            config.enable_pgle(True),\n            tempfile.TemporaryDirectory() as dump_dir,\n            tempfile.TemporaryDirectory() as cache_dir):\n        if enable_compilation_cache:\n          cc.reset_cache()\n          cc.set_cache_dir(cache_dir)\n        compiler_options = {\n          'xla_dump_to': dump_dir,\n          # FUSION, see https://github.com/openxla/xla/issues/22459\n          'xla_gpu_enable_command_buffer': 1,\n          'xla_gpu_graph_min_graph_size': 1,\n        }\n        @partial(\n            jax.jit,\n            compiler_options=compiler_options,\n        )\n        def f(x):\n          return x * 2\n    \n        x = jnp.arange(1)\n        expected = x * 2\n    \n        # This is ugly, but it does not seem possible to get the AutoPGLE-recompiled\n        # executable text (.lower(x).compile().as_text() or similar).\n        def get_new_files():\n          additions = set(os.listdir(dump_dir)) - get_new_files.seen_files\n          get_new_files.seen_files |= additions\n          new_files = list(filter(lambda f: f.endswith('debug_options'), additions))\n          assert len(new_files) == 1\n          with open(os.path.join(dump_dir, new_files[0])) as ifile:\n            return ifile.read()\n    \n        get_new_files.seen_files = set()\n    \n        # Run 1\n>       self.assertArraysEqual(f(x), expected)\n                               ^^^^\n\njax/tests/pgle_test.py:524: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:263: in cache_miss\n    executable, pgle_profiler, const_args) = _python_pjit_helper(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:146: in _python_pjit_helper\n    out_flat, compiled, profiler, const_args = _pjit_call_impl_python(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:1622: in _pjit_call_impl_python\n    return (compiled.unsafe_call(*computation.const_args, *args),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:359: in wrapper\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py:1367: in __call__\n    with profiler.PGLEProfiler.trace(self.pgle_profiler):\n/usr/lib/python3.12/contextlib.py:144: in __exit__\n    next(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'jax._src.profiler.PGLEProfiler'>\nrunner = <jax._src.profiler.PGLEProfiler object at 0x7f15d7d4b5c0>\n\n    @classmethod\n    @contextmanager\n    def trace(cls, runner: PGLEProfiler | None):\n      if (runner is None or runner.is_running()\n          or not runner.is_enabled() or runner.is_fdo_consumed()):\n        yield\n      else:\n        options = _profiler.ProfileOptions()\n        options.enable_hlo_proto = True\n        options.raise_error_on_start_failure = True\n        runner.current_session = _profiler.ProfilerSession(options)\n    \n        try:\n          yield\n        finally:\n          xspace = runner.current_session.stop()\n          runner.fdo_profiles.append(\n              _profiler.get_fdo_profile(xspace)\n          )\n          runner.current_session = None\n    \n          runner.called_times += 1\n          if runner.fdo_profiles[-1] == b'':\n>           warnings.warn(\n                \"PGLE collected an empty trace, may be due to contention with \"\n                \"another tool that subscribes to CUPTI, such as Nsight Systems - check \"\n                \"for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. \"\n                \"Consider populating a persistent compilation cache with PGLE enabled, \"\n                \"and then profiling a second run that has the \"\n                \"JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\",\n                RuntimeWarning)\nE           RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\n\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:468: RuntimeWarning"}, "teardown": {"duration": 0.00022378098219633102, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithCommandBuffers1", "lineno": 483, "outcome": "failed", "keywords": ["testAutoPgleWithCommandBuffers1", "__wrapped__", "__x_params_repr__", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.00021397601813077927, "outcome": "passed"}, "call": {"duration": 0.23483875393867493, "outcome": "failed", "crash": {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled."}, "traceback": [{"path": "jax/tests/pgle_test.py", "lineno": 524, "message": ""}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 263, "message": "in cache_miss"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 146, "message": "in _python_pjit_helper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 1622, "message": "in _pjit_call_impl_python"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 359, "message": "in wrapper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py", "lineno": 1367, "message": "in __call__"}, {"path": "/usr/lib/python3.12/contextlib.py", "lineno": 144, "message": "in __exit__"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning"}], "longrepr": "self = <tests.pgle_test.PgleTest testMethod=testAutoPgleWithCommandBuffers1>\nenable_compilation_cache = False\n\n    @parameterized.parameters([True, False])\n    @jtu.thread_unsafe_test()\n    def testAutoPgleWithCommandBuffers(self, enable_compilation_cache):\n      with (config.pgle_profiling_runs(1),\n            config.enable_compilation_cache(enable_compilation_cache),\n            config.enable_pgle(True),\n            tempfile.TemporaryDirectory() as dump_dir,\n            tempfile.TemporaryDirectory() as cache_dir):\n        if enable_compilation_cache:\n          cc.reset_cache()\n          cc.set_cache_dir(cache_dir)\n        compiler_options = {\n          'xla_dump_to': dump_dir,\n          # FUSION, see https://github.com/openxla/xla/issues/22459\n          'xla_gpu_enable_command_buffer': 1,\n          'xla_gpu_graph_min_graph_size': 1,\n        }\n        @partial(\n            jax.jit,\n            compiler_options=compiler_options,\n        )\n        def f(x):\n          return x * 2\n    \n        x = jnp.arange(1)\n        expected = x * 2\n    \n        # This is ugly, but it does not seem possible to get the AutoPGLE-recompiled\n        # executable text (.lower(x).compile().as_text() or similar).\n        def get_new_files():\n          additions = set(os.listdir(dump_dir)) - get_new_files.seen_files\n          get_new_files.seen_files |= additions\n          new_files = list(filter(lambda f: f.endswith('debug_options'), additions))\n          assert len(new_files) == 1\n          with open(os.path.join(dump_dir, new_files[0])) as ifile:\n            return ifile.read()\n    \n        get_new_files.seen_files = set()\n    \n        # Run 1\n>       self.assertArraysEqual(f(x), expected)\n                               ^^^^\n\njax/tests/pgle_test.py:524: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:263: in cache_miss\n    executable, pgle_profiler, const_args) = _python_pjit_helper(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:146: in _python_pjit_helper\n    out_flat, compiled, profiler, const_args = _pjit_call_impl_python(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:1622: in _pjit_call_impl_python\n    return (compiled.unsafe_call(*computation.const_args, *args),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:359: in wrapper\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py:1367: in __call__\n    with profiler.PGLEProfiler.trace(self.pgle_profiler):\n/usr/lib/python3.12/contextlib.py:144: in __exit__\n    next(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'jax._src.profiler.PGLEProfiler'>\nrunner = <jax._src.profiler.PGLEProfiler object at 0x7f15d7d48290>\n\n    @classmethod\n    @contextmanager\n    def trace(cls, runner: PGLEProfiler | None):\n      if (runner is None or runner.is_running()\n          or not runner.is_enabled() or runner.is_fdo_consumed()):\n        yield\n      else:\n        options = _profiler.ProfileOptions()\n        options.enable_hlo_proto = True\n        options.raise_error_on_start_failure = True\n        runner.current_session = _profiler.ProfilerSession(options)\n    \n        try:\n          yield\n        finally:\n          xspace = runner.current_session.stop()\n          runner.fdo_profiles.append(\n              _profiler.get_fdo_profile(xspace)\n          )\n          runner.current_session = None\n    \n          runner.called_times += 1\n          if runner.fdo_profiles[-1] == b'':\n>           warnings.warn(\n                \"PGLE collected an empty trace, may be due to contention with \"\n                \"another tool that subscribes to CUPTI, such as Nsight Systems - check \"\n                \"for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. \"\n                \"Consider populating a persistent compilation cache with PGLE enabled, \"\n                \"and then profiling a second run that has the \"\n                \"JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\",\n                RuntimeWarning)\nE           RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\n\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:468: RuntimeWarning"}, "teardown": {"duration": 0.00021822191774845123, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testAutoPgleWithPersistentCache", "lineno": 220, "outcome": "failed", "keywords": ["testAutoPgleWithPersistentCache", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.0002185925841331482, "outcome": "passed"}, "call": {"duration": 6.702476986683905, "outcome": "failed", "crash": {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled."}, "traceback": [{"path": "jax/tests/pgle_test.py", "lineno": 259, "message": ""}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 263, "message": "in cache_miss"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 146, "message": "in _python_pjit_helper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py", "lineno": 1622, "message": "in _pjit_call_impl_python"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 359, "message": "in wrapper"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py", "lineno": 1367, "message": "in __call__"}, {"path": "/usr/lib/python3.12/contextlib.py", "lineno": 144, "message": "in __exit__"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning"}], "longrepr": "self = <tests.pgle_test.PgleTest testMethod=testAutoPgleWithPersistentCache>\n\n    def testAutoPgleWithPersistentCache(self):\n      its = 50\n      mesh = jtu.create_mesh((2,), ('x',))\n    \n      with tempfile.TemporaryDirectory() as dump_dir:\n        compiler_options = {\n            'xla_gpu_enable_latency_hiding_scheduler': 'True',\n            'xla_dump_to': dump_dir,\n            'xla_gpu_experimental_dump_fdo_profiles': 'True',\n        }\n        # TODO(b/376647494): Remove this flag once the bug is fixed.\n        @partial(\n            jax.jit,\n            in_shardings=NamedSharding(mesh, PartitionSpec('x')),\n            out_shardings=NamedSharding(mesh, PartitionSpec('x')),\n            compiler_options=compiler_options,\n        )\n        def f(x):\n          agg = x\n          for _ in range(its):\n            agg = agg @ x\n          return agg\n    \n        shape = (16, 16)\n        x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    \n        with (config.enable_compilation_cache(True),\n              config.enable_pgle(True),\n              config.raise_persistent_cache_errors(True),\n              config.raise_persistent_cache_errors(True),\n              config.persistent_cache_min_entry_size_bytes(0),\n              config.persistent_cache_min_compile_time_secs(0),\n              config.pgle_profiling_runs(2),\n              tempfile.TemporaryDirectory() as cache_dir):\n          cc.reset_cache()\n          cc.set_cache_dir(cache_dir)\n          # Run 1: Module should be compiled without FDO\n          with jtu.count_jit_compilation_cache_miss() as cache_miss_count:\n>           f(x)\n\njax/tests/pgle_test.py:259: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:263: in cache_miss\n    executable, pgle_profiler, const_args) = _python_pjit_helper(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:146: in _python_pjit_helper\n    out_flat, compiled, profiler, const_args = _pjit_call_impl_python(\n/usr/local/lib/python3.12/dist-packages/jax/_src/pjit.py:1622: in _pjit_call_impl_python\n    return (compiled.unsafe_call(*computation.const_args, *args),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:359: in wrapper\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/dist-packages/jax/_src/interpreters/pxla.py:1367: in __call__\n    with profiler.PGLEProfiler.trace(self.pgle_profiler):\n/usr/lib/python3.12/contextlib.py:144: in __exit__\n    next(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'jax._src.profiler.PGLEProfiler'>\nrunner = <jax._src.profiler.PGLEProfiler object at 0x7f15d7c6c0e0>\n\n    @classmethod\n    @contextmanager\n    def trace(cls, runner: PGLEProfiler | None):\n      if (runner is None or runner.is_running()\n          or not runner.is_enabled() or runner.is_fdo_consumed()):\n        yield\n      else:\n        options = _profiler.ProfileOptions()\n        options.enable_hlo_proto = True\n        options.raise_error_on_start_failure = True\n        runner.current_session = _profiler.ProfilerSession(options)\n    \n        try:\n          yield\n        finally:\n          xspace = runner.current_session.stop()\n          runner.fdo_profiles.append(\n              _profiler.get_fdo_profile(xspace)\n          )\n          runner.current_session = None\n    \n          runner.called_times += 1\n          if runner.fdo_profiles[-1] == b'':\n>           warnings.warn(\n                \"PGLE collected an empty trace, may be due to contention with \"\n                \"another tool that subscribes to CUPTI, such as Nsight Systems - check \"\n                \"for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. \"\n                \"Consider populating a persistent compilation cache with PGLE enabled, \"\n                \"and then profiling a second run that has the \"\n                \"JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\",\n                RuntimeWarning)\nE           RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\n\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:468: RuntimeWarning"}, "teardown": {"duration": 0.00022756680846214294, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testPGLEProfilerGetFDOProfile", "lineno": 60, "outcome": "failed", "keywords": ["testPGLEProfilerGetFDOProfile", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.00044232234358787537, "outcome": "passed"}, "call": {"duration": 1.5472770733758807, "outcome": "failed", "crash": {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled."}, "traceback": [{"path": "jax/tests/pgle_test.py", "lineno": 87, "message": ""}, {"path": "/usr/lib/python3.12/contextlib.py", "lineno": 144, "message": "in __exit__"}, {"path": "/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py", "lineno": 468, "message": "RuntimeWarning"}], "longrepr": "self = <tests.pgle_test.PgleTest testMethod=testPGLEProfilerGetFDOProfile>\n\n    def testPGLEProfilerGetFDOProfile(self):\n      mesh = jtu.create_mesh((2,), ('x',))\n    \n      @partial(\n          jax.jit,\n          in_shardings=NamedSharding(mesh, PartitionSpec('x')),\n          out_shardings=NamedSharding(mesh, PartitionSpec('x')),\n          compiler_options={\n              'xla_gpu_enable_latency_hiding_scheduler': 'True',\n              # Make sure that matmul is not emitted as Triton GEMM.\n              'xla_gpu_enable_triton_gemm': 'False',\n          },\n      )\n      def f(x, y):\n        return x @ y\n    \n      shape = (16, 16)\n      x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n      y = x + 1\n    \n      with config.pgle_profiling_runs(0):\n        f_lowered = f.lower(x, y)\n        compiled = f_lowered.compile()\n    \n      pgle_profiler = profiler.PGLEProfiler(1, 90)\n      with config.enable_pgle(False):\n>       with profiler.PGLEProfiler.trace(pgle_profiler):\n\njax/tests/pgle_test.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/contextlib.py:144: in __exit__\n    next(self.gen)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'jax._src.profiler.PGLEProfiler'>\nrunner = <jax._src.profiler.PGLEProfiler object at 0x7f15d7ce19d0>\n\n    @classmethod\n    @contextmanager\n    def trace(cls, runner: PGLEProfiler | None):\n      if (runner is None or runner.is_running()\n          or not runner.is_enabled() or runner.is_fdo_consumed()):\n        yield\n      else:\n        options = _profiler.ProfileOptions()\n        options.enable_hlo_proto = True\n        options.raise_error_on_start_failure = True\n        runner.current_session = _profiler.ProfilerSession(options)\n    \n        try:\n          yield\n        finally:\n          xspace = runner.current_session.stop()\n          runner.fdo_profiles.append(\n              _profiler.get_fdo_profile(xspace)\n          )\n          runner.current_session = None\n    \n          runner.called_times += 1\n          if runner.fdo_profiles[-1] == b'':\n>           warnings.warn(\n                \"PGLE collected an empty trace, may be due to contention with \"\n                \"another tool that subscribes to CUPTI, such as Nsight Systems - check \"\n                \"for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. \"\n                \"Consider populating a persistent compilation cache with PGLE enabled, \"\n                \"and then profiling a second run that has the \"\n                \"JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\",\n                RuntimeWarning)\nE           RuntimeWarning: PGLE collected an empty trace, may be due to contention with another tool that subscribes to CUPTI, such as Nsight Systems - check for CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED from XLA. Consider populating a persistent compilation cache with PGLE enabled, and then profiling a second run that has the JAX_COMPILATION_CACHE_EXPECT_PGLE option enabled.\n\n/usr/local/lib/python3.12/dist-packages/jax/_src/profiler.py:468: RuntimeWarning"}, "teardown": {"duration": 0.0003037182614207268, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testPGLEProfilerGetFDOProfileLarge", "lineno": 93, "outcome": "failed", "keywords": ["testPGLEProfilerGetFDOProfileLarge", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.00021456647664308548, "outcome": "passed"}, "call": {"duration": 1.5700476514175534, "outcome": "failed", "crash": {"path": "/usr/lib/python3.12/unittest/case.py", "lineno": 878, "message": "AssertionError: 499 != 500"}, "traceback": [{"path": "jax/tests/pgle_test.py", "lineno": 125, "message": "AssertionError"}], "longrepr": "self = <tests.pgle_test.PgleTest testMethod=testPGLEProfilerGetFDOProfileLarge>\n\n    def testPGLEProfilerGetFDOProfileLarge(self):\n      mesh = jtu.create_mesh((2,), ('x',))\n      its = 500\n    \n      compiler_options = {\n          'xla_gpu_enable_latency_hiding_scheduler': 'True',\n          # Make sure that matmul is not emitted as Triton GEMM.\n          'xla_gpu_enable_triton_gemm': 'False',\n      }\n      # TODO(b/37664749): Remove this flag once the bug is fixed.\n      compiler_options['xla_gpu_enable_command_buffer'] = ''\n      @partial(\n          jax.jit,\n          in_shardings=NamedSharding(mesh, PartitionSpec('x')),\n          out_shardings=NamedSharding(mesh, PartitionSpec('x')),\n          compiler_options=compiler_options,\n      )\n      def f(x):\n        agg = x\n        for _ in range(its):\n          agg = agg @ x\n        return agg\n    \n      shape = (16, 16)\n      x = jnp.arange(math.prod(shape)).reshape(shape).astype(np.float32)\n    \n      pgle_profiler = profiler.PGLEProfiler(1, 90)\n      with config.enable_pgle(False):\n        with profiler.PGLEProfiler.trace(pgle_profiler):\n          f(x)\n      fdo_profile = pgle_profiler.consume_fdo_profile()\n>     self.assertEqual(fdo_profile.count(b'custom'), its)\nE     AssertionError: 499 != 500\n\njax/tests/pgle_test.py:125: AssertionError"}, "teardown": {"duration": 0.0001456858590245247, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testPassingFDOProfile", "lineno": 325, "outcome": "passed", "keywords": ["testPassingFDOProfile", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.00020741578191518784, "outcome": "passed"}, "call": {"duration": 1.5677185785025358, "outcome": "passed"}, "teardown": {"duration": 0.00013018213212490082, "outcome": "passed"}}, {"nodeid": "tests/pgle_test.py::PgleTest::testPersistentCachePopulatedWithAutoPgle", "lineno": 366, "outcome": "skipped", "keywords": ["testPersistentCachePopulatedWithAutoPgle", "PgleTest", "multiaccelerator", "pgle_test.py", "tests", "jax", ""], "setup": {"duration": 0.00020183809101581573, "outcome": "passed"}, "call": {"duration": 0.000446259044110775, "outcome": "skipped", "longrepr": "('/dockerx/rocm/rocm-jax/jax/tests/pgle_test.py', 367, 'Skipped: Test does not cleanly reset the compilation cache')"}, "teardown": {"duration": 0.0002311626449227333, "outcome": "passed"}}]}